
#include <fstream>
#include <iostream>
#include <regex>
#include <vector>
#include <string>
#include <sstream>

#include <geek/utils/searcher.h>
#include <geek/utils/file.h>
#include <geek/process/process.h>

#include <geek/hook/inline_hook.h>
#include <geek/asm/assembler.h>

#include <geek/asm/disassembler.h>

using namespace geek;
using namespace geek::asm_reg;

const unsigned char hexData[240] = {
	0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
	0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00,
	0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
	0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
	0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
	0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1D, 0x11, 0x45, 0x14, 0x59, 0xDC, 0xCE, 0xC8, 0x59, 0xDC, 0xCE, 0xC8, 0x59, 0xDC, 0xCE, 0xC8,
	0x49, 0x58, 0xCF, 0xC9, 0x5A, 0xDC, 0xCE, 0xC8, 0x49, 0x58, 0xCD, 0xC9, 0x5A, 0xDC, 0xCE, 0xC8,
	0x49, 0x58, 0xCA, 0xC9, 0x53, 0xDC, 0xCE, 0xC8, 0x49, 0x58, 0xCB, 0xC9, 0x4E, 0xDC, 0xCE, 0xC8,
	0x12, 0xA4, 0xCF, 0xC9, 0x5D, 0xDC, 0xCE, 0xC8, 0x59, 0xDC, 0xCF, 0xC8, 0x1C, 0xDC, 0xCE, 0xC8,
	0x12, 0x59, 0xCB, 0xC9, 0x58, 0xDC, 0xCE, 0xC8, 0x12, 0x59, 0x31, 0xC8, 0x58, 0xDC, 0xCE, 0xC8,
	0x12, 0x59, 0xCC, 0xC9, 0x58, 0xDC, 0xCE, 0xC8, 0x52, 0x69, 0x63, 0x68, 0x59, 0xDC, 0xCE, 0xC8,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x08, 0x00
};

// º‡ ”hook
void emm1() {
	int j = 1;
	int j2 = 1;
	int j3 = 1;
	int j4 = 1;
	std::cout << "emm1" << std::endl;
}

bool sbsb1(geek::InlineHook::HookContextX64* context) {
	std::cout << "sbsb1" << std::endl;
	emm1();
	return true;
}


// Ω”π‹hook
void emm2() {
	std::cout << "emm2" << std::endl;
}

bool sbsb2(geek::InlineHook::HookContextX64* context) {
	std::cout << "sbsb2" << std::endl;
	context->rsp += 4;
	context->jmp_addr = context->stack[0];
	return false;
}

class MyClass
{
public:
	MyClass(
		int a1,
		int a2,
		int a3,
		int a4)
		: a1_(a1)
		, a2_(a2)
		, a3_(a3)
		, a4_(a4)
	{

	}


	~MyClass();

private:
	int a1_;
	int a2_;
	int a3_;
	int a4_;
};

void jjjj() {
	printf("223---------------\n");
}

int jjjbb = 123;

int main() {
	// auto m = geek::ThisProc().Modules().FindByModuleName(L"example.exe");
	//
	// hexData[0];
	//
	// auto res = geek::ThisProc().SearchSig("11 45 14", m.DllBase(), m.SizeOfImage());
	//
	// for (auto o : res)
	// {
	// 	printf("%llx - %llx\n", o, *reinterpret_cast<const uint64_t*>(o));
	// }

	emm1();
	InlineHook::InstallX64((size_t)emm1, sbsb1);
	emm1();
}

// auto dir = geek::File::GetAppDirectory();
// auto proc_opt = geek::Process::Open(L"C:\\Windows\\notepad.exe", PROCESS_ALL_ACCESS);
// if (!proc_opt.has_value())
// {
// 	auto opt = geek::Process::Create(L"C:\\Windows\\notepad.exe");
// 	if (!opt.has_value())
// 	{
// 		return -1;
// 	}
// 	proc_opt = { std::move(std::get<0>(opt.value())) };
// }
// auto proc = std::move(proc_opt.value());